<html>
<head>
  <title>Mandelbrot set</title>
</head>
<script type="x-shader/x-vertex" id="passThruVS">
attribute vec2 coord;
varying vec2 pos;
void main(void) {
  pos = coord;
  gl_Position = vec4(coord, 0, 1.0);
}
</script>

<script type="x-shader/x-fragment" id="mandelbrotFS">
precision highp float;
varying vec2 pos;
uniform vec2 topLeft, bottomRight;
float sqrdistance(vec2 val) {
return val.x*val.x+val.y*val.y;
}
vec2 mandelbrotStep(vec2 z, vec2 c) {
  return vec2(z.x*z.x-z.y*z.y+c.x, 2.0*z.x*z.y + c.y);
}
void main(void) {
  vec2 z= vec2(0, 0);
  vec2 dim = bottomRight-topLeft;
  vec2 c = vec2(topLeft.x + dim.x*.5*(pos.x+1.0), bottomRight.y - dim.y*.5*(pos.y+1.0));
  for(int cnt = 0; cnt < 256; cnt++) {
    if (sqrdistance(z) >= 4.0) {
      gl_FragColor = vec4(abs(.5*z.x), float(cnt)/256.0, abs(.5*z.y), 1);
      return;
    }
    z = mandelbrotStep(z, c);
  }
  gl_FragColor = vec4(0, 0, 0, 1.0);
}
</script>

<script type="x-shader/x-fragment" id="solidColorFS">
uniform vec4 color;
void main(void) {
  gl_FragColor = color;
}
</script>

<script type="text/javascript">

class GLContext {
  constructor(canvas) {
    if (canvas == null)
      throw 'Can not find canvas';
    const ctx = canvas.getContext('webgl');
    if (ctx == null)
      throw 'Can not get WebGL context...';
    ctx.viewport(0, 0, canvas.clientWidth, canvas.clientHeight);
    ctx.clearColor(0, 0, 0, 1.0);
    ctx.clear(ctx.COLOR_BUFFER_BIT);
    this._ctx = ctx;
    this.PRIMITIVES = {
      POINTS: ctx.POINTS,
      LINE_STRIP: ctx.LINE_STRIP,
      LINES: ctx.LINES,
      TRIANGLE_STRIP: ctx.TRIANGLE_STRIP,
      TRIANGLES: ctx.TRIANGLES,
    };
  }

  getGLContext() {
    if (!this._ctx) throw 'Missing context';
    return this._ctx;
  }

  compileShader(type, source) {
    const glCtx = this.getGLContext();
    var rc = glCtx.createShader(type);
    glCtx.shaderSource(rc, source);
    glCtx.compileShader(rc);
    if (!glCtx.getShaderParameter(rc, glCtx.COMPILE_STATUS)) {
      throw glCtx.getShaderInfoLog(rc) + ' in ' + source;
    }
    return rc;
  }

  compileShaderById(id) {
    const glCtx = this.getGLContext();
    const element = document.getElementById(id);
    if (element == null) {
      throw 'Can not find shader by element id ' + id;
    }
    const source = element.innerHTML;
    if (element.type === 'x-shader/x-vertex') {
      return this.compileShader(glCtx.VERTEX_SHADER, source);
    }
    if (element.type === 'x-shader/x-fragment') {
      return this.compileShader(glCtx.FRAGMENT_SHADER, source);
    }
    throw 'Unknown shader type ' + element.type;
  }

  linkProgram(shaders) {
    const glCtx = this.getGLContext();
    const rc = glCtx.createProgram();
    for(var cnt = 0; cnt < shaders.length; cnt++) {
      if (!shaders[cnt]) {
        throw 'Can not link program with null shaders';
      }
      glCtx.attachShader(rc, shaders[cnt]);
    }
    glCtx.linkProgram(rc);
    if (!glCtx.getProgramParameter(rc, glCtx.LINK_STATUS)) {
      throw glCtx.getProgramInfoLog(rc);
    }
    return rc;
  }

  setUniform2f(name, a, b) {
    const glCtx = this.getGLContext();
    const prog = glCtx.getParameter(glCtx.CURRENT_PROGRAM);
    const idx = glCtx.getUniformLocation(prog, name);
    glCtx.uniform2f(idx, a, b);
  }

  draw2DArray(type, name, arr) {
    const glCtx = this.getGLContext();
    const prog = glCtx.getParameter(glCtx.CURRENT_PROGRAM);
    const idx = glCtx.getAttribLocation(prog, name);

    var buf = glCtx.createBuffer();
    glCtx.bindBuffer(glCtx.ARRAY_BUFFER, buf);
    glCtx.bufferData(glCtx.ARRAY_BUFFER, new Float32Array(arr), glCtx.STATIC_DRAW);

    glCtx.enableVertexAttribArray(idx);
    glCtx.vertexAttribPointer(idx, 2, glCtx.FLOAT, false, 0, 0);

    glCtx.drawArrays(type, 0, arr.length/2);
    glCtx.deleteBuffer(buf);
  }
}

function drawQuad(x0, y0, x1, y1) {
  ctx.draw2DArray(ctx.PRIMITIVES.TRIANGLE_STRIP, 'coord', [x0, y0, x1, y0, x0, y1, x1, y1]);
}

function renderMandel(sx,sy, ex,ey) {
  ctx.setUniform2f('topLeft', sx, sy);
  ctx.setUniform2f('bottomRight', ex, ey);
  drawQuad(-1, -1, 1, 1);
}

var ctx = null;
function configureRenderer() {
  const canvas = document.getElementById('canvas');
  try {
    ctx = new GLContext(canvas);
    const prog = ctx.linkProgram(['passThruVS', 'mandelbrotFS'].map(_ => ctx.compileShaderById(_)));
    ctx.getGLContext().useProgram(prog);
  } catch (e) {
    alert('Inialization failed: ' + e);
    return;
  }

  var start = {x:-2.0, y: -2.0};
  var end = {x:2.0, y:2.0};
  const aspect = (end.y-start.y)/(end.x-start.x);
  var downcoord = null;
  function offset2coord(evt) {
    return {
      x: start.x + (end.x-start.x)*evt.offsetX/canvas.clientWidth,
      y: start.y + (end.y-start.y)*evt.offsetY/canvas.clientHeight
    };
  }
  canvas.addEventListener("mousedown", (event) => {downcoord = offset2coord(event);});
  canvas.addEventListener("mouseup", (event) => {
    if (downcoord == null) return;
    const upcoord = offset2coord(event);
    const dim = {x:upcoord.x - downcoord.x, y: upcoord.y - downcoord.y};
    if (dim.x <= 0 || dim.y <= 0) {
      downcoord = null;
      return;
    }

    // Maintain aspect ratio
    if (dim.x*aspect > dim.y) {
      upcoord.y = downcoord.y + dim.x*aspect;
    } else if (dim.y/aspect > dim.x){
      upcoord.x = downcoord.x + dim.y/aspect;
    }

    start = downcoord;
    end = upcoord;
    renderMandel(start.x, start.y, end.x, end.y);
  });

  renderMandel(start.x, start.y, end.x, end.y);
}

</script>
<body onLoad="configureRenderer();">
  <H1>Mandelbrot Set rendered in fragment shader</H1>
  <canvas id="canvas" width="1024px" height="1024px"></canvas>
</body>
</html>
