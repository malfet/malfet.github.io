<html>
<head>
  <title>Mandelbrot set</title>
</head>
<script type="x-shader/x-vertex" id="passThruVS">
attribute vec2 coord;
varying vec2 pos;
void main(void) {
  pos = coord;
  gl_Position = vec4(coord, 0, 1.0);
}
</script>

<script type="x-shader/x-fragment" id="mandelbrotFS">
precision highp float;
varying vec2 pos;
uniform vec2 topLeft, bottomRight;
float sqrdistance(vec2 val) {
return val.x*val.x+val.y*val.y;
}
vec2 mandelbrotStep(vec2 z, vec2 c) {
  return vec2(z.x*z.x-z.y*z.y+c.x, 2.0*z.x*z.y + c.y);
}
void main(void) {
  vec2 z= vec2(0, 0);
  vec2 dim = bottomRight-topLeft;
  vec2 c = vec2(topLeft.x + dim.x*.5*(pos.x+1.0), bottomRight.y - dim.y*.5*(pos.y+1.0));
  for(int cnt = 0; cnt < 256; cnt++) {
    if (sqrdistance(z) >= 4.0) {
      gl_FragColor = vec4(abs(.5*z.x), float(cnt)/256.0, abs(.5*z.y), 1);
      return;
    }
    z = mandelbrotStep(z, c);
  }
  gl_FragColor = vec4(0, 0, 0, 1.0);
}
</script>

<script type="x-shader/x-fragment" id="solidColorFS">
uniform vec4 color;
void main(void) {
  gl_FragColor = color;
}
</script>

<script type="text/javascript">

class GLContext {
  constructor(canvas) {
    if (canvas == null)
      throw 'Can not find canvas';
    const ctx = canvas.getContext('webgl');
    if (ctx == null)
      throw 'Can not get WebGL context...';
    ctx.viewport(0, 0, canvas.clientWidth, canvas.clientHeight);
    ctx.clearColor(0, 0, 0, 1.0);
    ctx.clear(ctx.COLOR_BUFFER_BIT);
    this._ctx = ctx;
    this.PRIMITIVES = {
      POINTS: ctx.POINTS,
      LINE_STRIP: ctx.LINE_STRIP,
      LINES: ctx.LINES,
      TRIANGLE_STRIP: ctx.TRIANGLE_STRIP,
      TRIANGLES: ctx.TRIANGLES,
    };
  }

  getGLContext() {
    if (!this._ctx) throw 'Missing context';
    return this._ctx;
  }

  compileShader(type, source) {
    const glCtx = this.getGLContext();
    var rc = glCtx.createShader(type);
    glCtx.shaderSource(rc, source);
    glCtx.compileShader(rc);
    if (!glCtx.getShaderParameter(rc, glCtx.COMPILE_STATUS)) {
      throw glCtx.getShaderInfoLog(rc) + ' in ' + source;
    }
    return rc;
  }

  compileShaderById(id) {
    const glCtx = this.getGLContext();
    const element = document.getElementById(id);
    if (element == null) {
      throw 'Can not find shader by element id ' + id;
    }
    const source = element.innerHTML;
    if (element.type === 'x-shader/x-vertex') {
      return this.compileShader(glCtx.VERTEX_SHADER, source);
    }
    if (element.type === 'x-shader/x-fragment') {
      return this.compileShader(glCtx.FRAGMENT_SHADER, source);
    }
    throw 'Unknown shader type ' + element.type;
  }

  linkProgram(shaders) {
    const glCtx = this.getGLContext();
    const rc = glCtx.createProgram();
    for(var cnt = 0; cnt < shaders.length; cnt++) {
      if (!shaders[cnt]) {
        throw 'Can not link program with null shaders';
      }
      glCtx.attachShader(rc, shaders[cnt]);
    }
    glCtx.linkProgram(rc);
    if (!glCtx.getProgramParameter(rc, glCtx.LINK_STATUS)) {
      throw glCtx.getProgramInfoLog(rc);
    }
    return rc;
  }

  setUniform2f(name, a, b) {
    const glCtx = this.getGLContext();
    const prog = glCtx.getParameter(glCtx.CURRENT_PROGRAM);
    const idx = glCtx.getUniformLocation(prog, name);
    glCtx.uniform2f(idx, a, b);
  }

  draw2DArray(type, name, arr) {
    const glCtx = this.getGLContext();
    const prog = glCtx.getParameter(glCtx.CURRENT_PROGRAM);
    const idx = glCtx.getAttribLocation(prog, name);

    var buf = glCtx.createBuffer();
    glCtx.bindBuffer(glCtx.ARRAY_BUFFER, buf);
    glCtx.bufferData(glCtx.ARRAY_BUFFER, new Float32Array(arr), glCtx.STATIC_DRAW);

    glCtx.enableVertexAttribArray(idx);
    glCtx.vertexAttribPointer(idx, 2, glCtx.FLOAT, false, 0, 0);

    glCtx.drawArrays(type, 0, arr.length/2);
    glCtx.deleteBuffer(buf);
  }
}

class Point {
  constructor(x, y) {
    this.x = x; this.y = y;
  }
  sub(p) { return new Point(this.x-p.x, this.y-p.y); }
  add(p) { return new Point(this.x+p.x, this.y+p.y); }
  mul(a) { return new Point(a*this.x, a*this.y); }
}

class ZoomRenderer {
  constructor(canvas) {
    const ctx = new GLContext(canvas);
    const prog = ctx.linkProgram(['passThruVS', 'mandelbrotFS'].map(_ => ctx.compileShaderById(_)));
    canvas.addEventListener('click', (event) => {
      const clickTime = Date.now();
      if (clickTime - this._prevClickTime > 300) {
        this._prevClickTime = clickTime;
        return;
      }
      this._scale *= .5;
      this._center = this.canvas2rendercoord(event.offsetX, event.offsetY);
      this._prevClickTime = 0;
      this.render();
    });
    ctx.getGLContext().useProgram(prog);
    this._prevClickTime = 0;
    this._ctx = ctx;
    this._canvasDim = new Point(canvas.clientWidth, canvas.clientHeight);
    this._scale = 4.0/Math.min(canvas.clientWidth, canvas.clientHeight);
    this._center = new Point(0.0, 0.0);
    this._zoom = 1.0;
  }
  canvas2rendercoord(x, y) {
    const start = this._center.sub(this._canvasDim.mul(.5*this._scale));
    return start.add(new Point(x,y).mul(this._scale));
  }
  drawQuad(x0, y0, x1, y1) {
    this._ctx.draw2DArray(this._ctx.PRIMITIVES.TRIANGLE_STRIP, 'coord', [x0, y0, x1, y0, x0, y1, x1, y1]);
  }
  render() {
    const topLeft = this.canvas2rendercoord(0,0);
    const bottomRight = this.canvas2rendercoord(this._canvasDim.x, this._canvasDim.y);
    const ctx = this._ctx;
    ctx.setUniform2f('topLeft', topLeft.x, topLeft.y);
    ctx.setUniform2f('bottomRight', bottomRight.x, bottomRight.y);
    this.drawQuad(-1,-1, 1, 1);
  }
}

var renderer = null;
function configureRenderer() {
  const canvas = document.getElementById('canvas');
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  try {
    renderer = new ZoomRenderer(canvas);
  } catch (e) {
    alert('Inialization failed: ' + e);
    return;
  }
  renderer.render();
}

</script>
<body onLoad="configureRenderer();">
  <H1>Mandelbrot Set rendered in fragment shader</H1>
  <canvas id="canvas" width="1024px" height="1024px"></canvas>
</body>
</html>
