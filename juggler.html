<html>
<head>
  <title>RayTracing example</title>
</head>
<script type="x-shader/x-vertex" id="passThruVS">
attribute vec2 coord;
varying vec2 pos;
void main(void) {
  pos = coord;
  gl_Position = vec4(coord, 0, 1.0);
  gl_PointSize = 1.0;
}
</script>

<script type="x-shader/x-fragment" id="rayTrackingFS">
precision highp float;
varying vec2 pos;

const float THRESHOLD = 1e-1;


struct PointLight {
  vec3 location;
  vec3 color;
  float attenuation;
};

struct Object {
  // For sphere, quat.xyz is center, quat.w is radius
  // For plane, quat.xyz is normal, quat.w is D
  vec4 quat;
  vec3 color;
  // Light coefficients
  vec4 material; //.x is ambient, .y is diffuse, .z is specular and w is reflect
  int type;// 0 <- sphere, 1 <- plane, 2 <- checkered sphere, 3 <- checkered plane
};
struct Camera {
  vec3 location;
  vec3 vx,vy,vz;
};

struct Ray {
  vec3 origin, dir;
};

float sqr(float x) { return x*x; }

bool ObjectIntersect(in Object obj, in Ray ray, out float distance) {
  if (obj.type == 1 || obj.type == 3) {
    float cf = dot(obj.quat.xyz, ray.dir);
    if (abs(cf) < THRESHOLD)
      return false;
    distance = -( dot(obj.quat.xyz, ray.origin ) + obj.quat.w ) / cf;
    return distance >= THRESHOLD;
  }
  if (obj.type == 0 || obj.type == 2) {
    // Intersection of ray with sphere is a quadratic equation
    // len(ray.origin + distance*ray.direction - sphere.location) = sphere.radius
    // which is identical to
    // sqr(distance) + 2*distance*dot(ray.direction, OC) + dot(OC,OC) - sqr(radius)
    // where OC is ray.origin - sphere.location

    vec3 oc = obj.quat.xyz - ray.origin;
    float ocd = dot(oc, ray.dir);
    float d4 = sqr(obj.quat.w) + sqr(ocd) - dot(oc, oc);
    if (d4 < 0.0)
      return false;
    d4 = sqrt(d4);
    distance = ocd - d4;
    if (distance <= THRESHOLD)
      distance = ocd + d4;
    return distance >= THRESHOLD;
  }
  return false;
}

// Scene defenition
vec3 White  = vec3(1.0, 1.0, 1.0);

const int numLights = 1;
const int numObjects = 71;
uniform Object objects[numObjects];
uniform PointLight lights[numLights];
uniform Camera camera;

struct SurfaceProps {
  // Light coefficients
  float ambient, diffuse, specular, reflect;
  vec3 point;
  vec3 color;
  vec3 norm;
};

bool Scene_Intersects(in Ray ray) {
    for(int idx = 0; idx < numObjects; ++idx) {
      float d;
      if (ObjectIntersect(objects[idx], ray, d)) {
        return true;
      }
    }
    return false;
}

int Scene_Intersect(in Ray ray, out SurfaceProps props) {
  float bestDistance = 1e6;
  int bestIdx = -1;
  for(int idx = 0; idx < numObjects; ++idx) {
    float d;
    if (ObjectIntersect(objects[idx], ray, d)) {
      if (d < bestDistance) {
        bestDistance = d;
        bestIdx = idx;
      }
    }
  }
  if (bestIdx < 0) return bestIdx;
  props.point = ray.origin + bestDistance * ray.dir;
  for(int idx = 0; idx < numObjects; ++idx) {
    if (idx != bestIdx) continue;

    if (objects[idx].type == 0 || objects[idx].type == 2) {
      props.norm = normalize(props.point - objects[idx].quat.xyz);
    } else {
      props.norm  = objects[idx].quat.xyz;
    }

    props.color = objects[idx].color;
    props.ambient = objects[idx].material.x;
    props.diffuse = objects[idx].material.y;
    props.specular = objects[idx].material.z;
    props.reflect = objects[idx].material.w;

    // Checked sphere pattern
    if (objects[idx].type == 2) {
      if (mod(floor(atan(props.norm.x/props.norm.z)*4.0),2.0) == 0.0
      ^^ mod(floor(acos(props.norm.y)*4.0),2.0) == 0.0) {
        props.color = vec3(1.0)-props.color;
      }
    }
    // Checked plane pattern
    if (objects[idx].type == 3) {
      vec3 px = props.norm.z == 0.0 ? vec3(-props.norm.y, props.norm.x, 0.0) : normalize(cross(props.norm, vec3(1.0,0,0)));
      vec3 py = cross(px,props.norm);
      vec3 origin =  -objects[idx].quat.w*objects[idx].quat.xyz;
      vec3 offs = props.point - origin;
      if (mod(floor(dot(offs,px)),2.0) == 0.0 ^^ mod(floor(dot(offs,py)),2.0) == 0.0) {
        props.color = vec3(1.0)-props.color;
      }
    }
  }
  return bestIdx;
}

void main(void) {
  Ray ray = Ray(camera.location, normalize(camera.vz+.6*pos.x*camera.vx + .6*pos.y*camera.vy));
  vec3 color = vec3(0.0);
  float weight = 1.0;
  SurfaceProps props;
  for(int depth = 0; depth < 5; ++depth) {
    int objIdx = Scene_Intersect(ray, props);
    if (objIdx < 0) {
      if (depth == 0)
        color = vec3(0.196, 0.6, 0.8);
      break;
    }
    color += weight * props.ambient * props.color;
    for(int idx = 0; idx < numLights; ++idx) {
      vec3 lightDir = lights[idx].location - props.point;
      Ray lightRay = Ray(props.point, normalize(lightDir));
      // Check if light is occluded
      if (Scene_Intersects(lightRay)) continue;
      float attenuation = sqr(lights[idx].attenuation)/dot(lightDir, lightDir);
      float angle = abs(dot(lightRay.dir, props.norm));
      if (angle < THRESHOLD) continue;

      // Add diffuse light component
      if (props.diffuse >= THRESHOLD)
        color += weight*props.diffuse*angle*attenuation*lights[idx].color*props.color;
      // Add specular light component using Blinnâ€“Phong reflection mode
      if (props.specular >= THRESHOLD) {
        vec3 halfway = normalize(lightRay.dir - ray.dir);
        color += weight*props.specular*attenuation*pow(dot(halfway, props.norm), 30.0)*lights[idx].color;
      }
    }
    if (weight * props.reflect < THRESHOLD) {
      break;
    }
    float viewAngle = dot(ray.dir, props.norm);
    weight *= props.reflect;
    ray.dir -= props.norm * 2.0 * viewAngle;
    ray.origin = props.point;
  }

  gl_FragColor = vec4(color, 1.0);
}
</script>

<script type="text/javascript">
function rotateX(angle) {
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);
  return [
    1,    0,    0,
    0,  cos, -sin,
    0,  sin,  cos,
  ];
}

function rotateY(angle) {
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);
  return [
    cos,    0,  sin,
      0,    1,    0,
   -sin,    0,  cos,
  ];
}

function rotateZ(angle) {
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);
  return [
    cos, -sin,  0,
    sin,  cos,  0,
      0,    0,  1,
  ];
}

function mulMatVec(mat, vec) {
  return [
    vec[0]*mat[0] + vec[1]*mat[1] + vec[2]*mat[2],
    vec[0]*mat[3] + vec[1]*mat[4] + vec[2]*mat[5],
    vec[0]*mat[6] + vec[1]*mat[7] + vec[2]*mat[8],
  ];
}

function mulMatMat(mata, matb) {
  const c1 = mulMatVec(mata, [matb[0], matb[3], matb[6]])
  const c2 = mulMatVec(mata, [matb[1], matb[4], matb[7]])
  const c3 = mulMatVec(mata, [matb[2], matb[5], matb[8]])
  return [
    c1[0], c2[0], c3[0],
    c1[1], c2[1], c3[1],
    c1[2], c2[2], c3[2],
  ];
}


class GLContext {
  constructor(canvas) {
    if (canvas == null)
      throw 'Can not find canvas';
    const ctx = canvas.getContext('webgl');
    if (ctx == null)
      throw 'Can not get WebGL context...';
    ctx.viewport(0, 0, canvas.clientWidth, canvas.clientHeight);
    ctx.clearColor(0, 0, 0, 1.0);
    ctx.clear(ctx.COLOR_BUFFER_BIT);
    this._ctx = ctx;
    this.PRIMITIVES = {
      POINTS: ctx.POINTS,
      LINE_STRIP: ctx.LINE_STRIP,
      LINES: ctx.LINES,
      TRIANGLE_STRIP: ctx.TRIANGLE_STRIP,
      TRIANGLES: ctx.TRIANGLES,
    };
    this.VERTEX_SHADER = ctx.VERTEX_SHADER;
    this.FRAGMENT_SHADER = ctx.FRAGMENT_SHADER;
  }

  getGLContext() {
    if (!this._ctx) throw 'Missing context';
    return this._ctx;
  }

  compileShader(type, source) {
    const glCtx = this.getGLContext();
    var rc = glCtx.createShader(type);
    glCtx.shaderSource(rc, source);
    glCtx.compileShader(rc);
    if (!glCtx.getShaderParameter(rc, glCtx.COMPILE_STATUS)) {
      throw glCtx.getShaderInfoLog(rc) + ' in ' + source;
    }
    return rc;
  }

  getElementById(id) {
    const element = document.getElementById(id);
    if (element == null) {
      throw 'Can not find shader by element id ' + id;
    }
     return element;
  }

  compileShaderById(id) {
    const glCtx = this.getGLContext();
    const element = this.getElementById(id);
    const source = element.innerHTML;
    if (element.type === 'x-shader/x-vertex') {
      return this.compileShader(glCtx.VERTEX_SHADER, source);
    }
    if (element.type === 'x-shader/x-fragment') {
      return this.compileShader(glCtx.FRAGMENT_SHADER, source);
    }
    throw 'Unknown shader type ' + element.type;
  }

  linkProgram(shaders) {
    const glCtx = this.getGLContext();
    const rc = glCtx.createProgram();
    for(var cnt = 0; cnt < shaders.length; cnt++) {
      if (!shaders[cnt]) {
        throw 'Can not link program with null shaders';
      }
      glCtx.attachShader(rc, shaders[cnt]);
    }
    glCtx.linkProgram(rc);
    if (!glCtx.getProgramParameter(rc, glCtx.LINK_STATUS)) {
      throw glCtx.getProgramInfoLog(rc);
    }
    return rc;
  }

  setUniformf(name) {
    const glCtx = this.getGLContext();
    const prog = glCtx.getParameter(glCtx.CURRENT_PROGRAM);
    const idx = glCtx.getUniformLocation(prog, name);
    if (arguments.length == 2)
      glCtx.uniform1f(idx, arguments[1]);
    else if (arguments.length == 3)
      glCtx.uniform2f(idx, arguments[1], arguments[2]);
    else if (arguments.length == 4)
      glCtx.uniform3f(idx, arguments[1], arguments[2], arguments[3]);
    else if (arguments.length == 5)
      glCtx.uniform4f(idx, arguments[1], arguments[2], arguments[3], arguments[4]);
    else
      throw "Unsupported number of uniform arguments";
  }

  setUniformi(name) {
    const glCtx = this.getGLContext();
    const prog = glCtx.getParameter(glCtx.CURRENT_PROGRAM);
    const idx = glCtx.getUniformLocation(prog, name);
    if (arguments.length == 2)
      glCtx.uniform1i(idx, arguments[1]);
    else if (arguments.length == 3)
      glCtx.uniform2i(idx, arguments[1], arguments[2]);
    else if (arguments.length == 4)
      glCtx.uniform3i(idx, arguments[1], arguments[2], arguments[3]);
    else if (arguments.length == 5)
      glCtx.uniform4i(idx, arguments[1], arguments[2], arguments[3], arguments[4]);
    else
      throw "Unsupported number of uniform arguments";
  }


  draw2DArray(type, name, arr) {
    const glCtx = this.getGLContext();
    const prog = glCtx.getParameter(glCtx.CURRENT_PROGRAM);
    const idx = glCtx.getAttribLocation(prog, name);

    var buf = glCtx.createBuffer();
    glCtx.bindBuffer(glCtx.ARRAY_BUFFER, buf);
    glCtx.bufferData(glCtx.ARRAY_BUFFER, new Float32Array(arr), glCtx.STATIC_DRAW);

    glCtx.enableVertexAttribArray(idx);
    glCtx.vertexAttribPointer(idx, 2, glCtx.FLOAT, false, 0, 0);

    glCtx.drawArrays(type, 0, arr.length/2);
    glCtx.deleteBuffer(buf);
  }
}

class RayTracerScene {
  constructor(canvas) {
    const ctx = new GLContext(canvas);
    const prog = ctx.linkProgram(['passThruVS', 'rayTrackingFS'].map(_ => ctx.compileShaderById(_)));
    ctx.getGLContext().useProgram(prog);

    this.ctx = ctx;
    this.aspect = canvas.clientWidth/canvas.clientHeight;

    this.setCamera(0, 2.5, -10);

    //plane
    ctx.setUniformi('objects[0].type', 3);
    ctx.setUniformf('objects[0].quat', 0, 1, 0, 0);
    this.setColor(0, 0, 0, 1);
    this.setMaterialProps(0, .1, .5, .4, .4);

    // Juggler spheres from http://www.etwright.org/cghist/rt2.js
    var juggler_spheres = [
     {pos: [-0.9,-2.1,5.3], color: [0.9,0.9,0.9], radius: 0.6, type: 2},
     {pos: [-1.1,1.9,5.9], color: [0.9,0.9,0.9], radius: 0.6, type: 2},
     {pos: [-0.4,-1.2,6.8], color: [0.9,0.9,0.9], radius: 0.6, type: 2},
     {pos: [0,0,6.1], color: [1,0.7,0.7], radius: 0.5, type: 1},
     {pos: [0.02,0,6.12], color: [0.2,0.1,0.1], radius: 0.5, type: 1},
     {pos: [-0.4,0.2,6.1], color: [0.1,0.1,1], radius: 0.15, type: 1},
     {pos: [-0.4,-0.2,6.1], color: [0.1,0.1,1], radius: 0.15, type: 1},
     {pos: [0,0,5.5], color: [1,0.7,0.7], radius: 0.2, type: 1},
     {pos: [0,0,4.6], color: [1,0.1,0.1], radius: 0.8, type: 1},
     {pos: [0,0,4.34], color: [1,0.1,0.1], radius: 0.76, type: 1},
     {pos: [0,0,4.08], color: [1,0.1,0.1], radius: 0.72, type: 1},
     {pos: [0,0,3.82], color: [1,0.1,0.1], radius: 0.68, type: 1},
     {pos: [0,0,3.56], color: [1,0.1,0.1], radius: 0.64, type: 1},
     {pos: [0,0,3.3], color: [1,0.1,0.1], radius: 0.6, type: 1},
     {pos: [0,0.6,2.9], color: [1,0.7,0.7], radius: 0.2, type: 1},
     {pos: [-0.1,0.6,2.68333], color: [1,0.7,0.7], radius: 0.2, type: 1},
     {pos: [-0.2,0.6,2.46667], color: [1,0.7,0.7], radius: 0.2, type: 1},
     {pos: [-0.3,0.6,2.25], color: [1,0.7,0.7], radius: 0.2, type: 1},
     {pos: [-0.4,0.6,2.03333], color: [1,0.7,0.7], radius: 0.2, type: 1},
     {pos: [-0.5,0.6,1.81667], color: [1,0.7,0.7], radius: 0.2, type: 1},
     {pos: [-0.6,0.6,1.6], color: [1,0.7,0.7], radius: 0.2, type: 1},
     {pos: [-0.571429,0.6,1.37143], color: [1,0.7,0.7], radius: 0.185714, type: 1},
     {pos: [-0.542857,0.6,1.14286], color: [1,0.7,0.7], radius: 0.171429, type: 1},
     {pos: [-0.514286,0.6,0.914286], color: [1,0.7,0.7], radius: 0.157143, type: 1},
     {pos: [-0.485714,0.6,0.685714], color: [1,0.7,0.7], radius: 0.142857, type: 1},
     {pos: [-0.457143,0.6,0.457143], color: [1,0.7,0.7], radius: 0.128571, type: 1},
     {pos: [-0.428571,0.6,0.228571], color: [1,0.7,0.7], radius: 0.114286, type: 1},
     {pos: [-0.4,0.6,0], color: [1,0.7,0.7], radius: 0.1, type: 1},
     {pos: [0,-0.6,2.9], color: [1,0.7,0.7], radius: 0.2, type: 1},
     {pos: [0.0333333,-0.6,2.68333], color: [1,0.7,0.7], radius: 0.2, type: 1},
     {pos: [0.0666667,-0.6,2.46667], color: [1,0.7,0.7], radius: 0.2, type: 1},
     {pos: [0.1,-0.6,2.25], color: [1,0.7,0.7], radius: 0.2, type: 1},
     {pos: [0.133333,-0.6,2.03333], color: [1,0.7,0.7], radius: 0.2, type: 1},
     {pos: [0.166667,-0.6,1.81667], color: [1,0.7,0.7], radius: 0.2, type: 1},
     {pos: [0.2,-0.6,1.6], color: [1,0.7,0.7], radius: 0.2, type: 1},
     {pos: [0.228571,-0.6,1.37143], color: [1,0.7,0.7], radius: 0.185714, type: 1},
     {pos: [0.257143,-0.6,1.14286], color: [1,0.7,0.7], radius: 0.171429, type: 1},
     {pos: [0.285714,-0.6,0.914286], color: [1,0.7,0.7], radius: 0.157143, type: 1},
     {pos: [0.314286,-0.6,0.685714], color: [1,0.7,0.7], radius: 0.142857, type: 1},
     {pos: [0.342857,-0.6,0.457143], color: [1,0.7,0.7], radius: 0.128571, type: 1},
     {pos: [0.371429,-0.6,0.228571], color: [1,0.7,0.7], radius: 0.114286, type: 1},
     {pos: [0.4,-0.6,0], color: [1,0.7,0.7], radius: 0.1, type: 1},
     {pos: [0,-0.7,5.1], color: [1,0.7,0.7], radius: 0.2, type: 1},
     {pos: [-0.0333333,-0.783333,4.95], color: [1,0.7,0.7], radius: 0.2, type: 1},
     {pos: [-0.0666667,-0.866667,4.8], color: [1,0.7,0.7], radius: 0.2, type: 1},
     {pos: [-0.1,-0.95,4.65], color: [1,0.7,0.7], radius: 0.2, type: 1},
     {pos: [-0.133333,-1.03333,4.5], color: [1,0.7,0.7], radius: 0.2, type: 1},
     {pos: [-0.166667,-1.11667,4.35], color: [1,0.7,0.7], radius: 0.2, type: 1},
     {pos: [-0.2,-1.2,4.2], color: [1,0.7,0.7], radius: 0.2, type: 1},
     {pos: [-0.328571,-1.31429,4.18571], color: [1,0.7,0.7], radius: 0.185714, type: 1},
     {pos: [-0.457143,-1.42857,4.17143], color: [1,0.7,0.7], radius: 0.171429, type: 1},
     {pos: [-0.585714,-1.54286,4.15714], color: [1,0.7,0.7], radius: 0.157143, type: 1},
     {pos: [-0.714286,-1.65714,4.14286], color: [1,0.7,0.7], radius: 0.142857, type: 1},
     {pos: [-0.842857,-1.77143,4.12857], color: [1,0.7,0.7], radius: 0.128571, type: 1},
     {pos: [-0.971429,-1.88571,4.11429], color: [1,0.7,0.7], radius: 0.114286, type: 1},
     {pos: [-1.1,-2,4.1], color: [1,0.7,0.7], radius: 0.1, type: 1},
     {pos: [0,0.7,5.1], color: [1,0.7,0.7], radius: 0.2, type: 1},
     {pos: [-0.0333333,0.783333,4.95], color: [1,0.7,0.7], radius: 0.2, type: 1},
     {pos: [-0.0666667,0.866667,4.8], color: [1,0.7,0.7], radius: 0.2, type: 1},
     {pos: [-0.1,0.95,4.65], color: [1,0.7,0.7], radius: 0.2, type: 1},
     {pos: [-0.133333,1.03333,4.5], color: [1,0.7,0.7], radius: 0.2, type: 1},
     {pos: [-0.166667,1.11667,4.35], color: [1,0.7,0.7], radius: 0.2, type: 1},
     {pos: [-0.2,1.2,4.2], color: [1,0.7,0.7], radius: 0.2, type: 1},
     {pos: [-0.314286,1.3,4.28571], color: [1,0.7,0.7], radius: 0.185714, type: 1},
     {pos: [-0.428571,1.4,4.37143], color: [1,0.7,0.7], radius: 0.171429, type: 1},
     {pos: [-0.542857,1.5,4.45714], color: [1,0.7,0.7], radius: 0.157143, type: 1},
     {pos: [-0.657143,1.6,4.54286], color: [1,0.7,0.7], radius: 0.142857, type: 1},
     {pos: [-0.771429,1.7,4.62857], color: [1,0.7,0.7], radius: 0.128571, type: 1},
     {pos: [-0.885714,1.8,4.71429], color: [1,0.7,0.7], radius: 0.114286, type: 1},
     {pos: [-1,1.9,4.8], color: [1,0.7,0.7], radius: 0.1, type: 1},
    ];

    for(var i = 0; i < juggler_spheres.length; ++i) {
      let color = juggler_spheres[i]['color'];
      let pos = juggler_spheres[i]['pos'];
      let radius = juggler_spheres[i]['radius'];
      let matType = juggler_spheres[i]['type'];
      ctx.setUniformi('objects[' +(i+1) + '].type', 0);
      ctx.setUniformf('objects[' +(i+1) + '].quat', pos[1], pos[2], pos[0], radius);
      this.setColor(i + 1, color[0], color[1], color[2]);
      if (matType == 1) {
        this.setMaterialProps(i + 1, .4, .6, .4, .0);
      } else {
        // Mirror
        this.setMaterialProps(i + 1, .1, .4, .8, .9);
      }
    }


    // Lights
    ctx.setUniformf('lights[0].location', 50, 150, -100);
    ctx.setUniformf('lights[0].color', 1, 1, 1);
    ctx.setUniformf('lights[0].attenuation', 190);

  }

  render(x0 = -1.0, y0 = -1.0, x1 = 1.0, y1 = 1.0) {
    this.ctx.draw2DArray(this.ctx.PRIMITIVES.TRIANGLE_STRIP, 'coord', [x0, y0, x1, y0, x0, y1, x1, y1]);
  }

  setColor(i,r,g,b) {
    this.ctx.setUniformf('objects['+i+'].color',r,g,b);
  }

  setMaterialProps(i, a=0, d=0, s=0, r=0) {
    this.ctx.setUniformf('objects['+i+'].material',a, d, s, r);
  }

  setCamera(x=0, y=0, z=-1) {
    this.ctx.setUniformf('camera.location', x, y, z);
    this.ctx.setUniformf('camera.vx', this.aspect, 0, 0);
    this.ctx.setUniformf('camera.vy', 0, 1, 0);
    this.ctx.setUniformf('camera.vz', 0, 0, 1);
  }

  setCameraRotation(longitude, latitude, spin) {
    var mat = mulMatMat(rotateY(-latitude), rotateX(longitude));
    this.ctx.setUniformf('camera.vx', this.aspect*mat[0], this.aspect*mat[3], this.aspect*mat[6]);
    this.ctx.setUniformf('camera.vy', mat[1], mat[4], mat[7]);
    this.ctx.setUniformf('camera.vz', mat[2], mat[5], mat[8]);
  }

}


var orientationEventReceived = false;

function registerMotionEventListener() {
  var compOrientation = {alpha: 0, beta: 0, gamma: 0};
  window.addEventListener('devicemotion', function(event) {
    orientationEventReceived = true;
    compOrientation.alpha += event.rotationRate.alpha*event.interval;
    compOrientation.beta += event.rotationRate.beta*event.interval;
    compOrientation.gamma += event.rotationRate.gamma*event.interval;

    const alpha = Math.PI* compOrientation.alpha / 180;
    const beta = Math.PI* compOrientation.beta / 180;
    const gamma = Math.PI* compOrientation.gamma / 180;
    if (window.orientation == 0.0) {
      scene.setCameraRotation(alpha, beta, gamma);
    } else if (window.orientation == 90.0) {
        scene.setCameraRotation(beta, alpha, alpha);
    } else if (window.orientation == -90.0) {
        scene.setCameraRotation(-beta, -alpha, alpha);
    } else {
      scene.setCameraRotation(0, 0, 0);
    }
    scene.render();
  });
}

function requestPermissions() {
  if (typeof DeviceMotionEvent === 'undefined') {
    return;
  }
  if (typeof DeviceMotionEvent.requestPermission !== 'function') {
    return;
  }
  DeviceMotionEvent.requestPermission(function(state) {
    if (state == 'granted') {
      registerMotionEventListener();
    }
  }).catch(console.error);
}

function displayClickToEnable() {
  document.getElementById('click-to-enable').style.visibility='visible';
}

function configureTracer() {
  const canvas = document.getElementById('canvas');
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  try {
    scene = new RayTracerScene(canvas);
    scene.render();
    canvas.addEventListener('mousemove', function(event) {
      var xn = scene.aspect*(event.x/canvas.clientWidth - .5);
      var yn = (event.y/canvas.clientHeight - .5);
      scene.setCamera(xn, 2.5 + yn, -10);
      //scene.setCameraRotation(xn, yn,0);

      scene.render();
    });
    registerMotionEventListener();
    setTimeout(function() {
      if (orientationEventReceived) {
        return;
      }
      displayClickToEnable();
    }, 1500);
  } catch (e) {
    alert('Inialization failed: ' + e);
    return;
  }
}

</script>

</script>
<body onLoad="configureTracer();">
<DIV>
  <H1 style="display:inline">RayTracer as fragment shader</H1>
  <DIV style="display:inline;visibility:hidden" id="click-to-enable">
   <INPUT TYPE="submit" onClick="requestPermissions();" value="Click here to enable orientation events" />
  </DIV>
  <canvas id="canvas" width="1024px" height="1024px"></canvas>
</body>
</html>
